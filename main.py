# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JHVIg9qD-bLKXWRn047OX7J_rXpcqjt7
"""

# Importing basic libraries
import pandas as pd
import tkinter as tk
import tkinter.ttk as ttk
import zipfile
import numpy as np
import os
from datetime import datetime, timedelta
from sklearn.metrics import mean_squared_error
from tkinter import filedialog
from PIL import Image, ImageTk

# Create an instance of Tkinter window
window = tk.Tk()

t1 = pd.DataFrame({})
t2 = pd.DataFrame()

# Set the window title
window.title("My User Interface")

# Set the window size
window.geometry("800x700")
window.configure(bg="white")

# Load Image
image = Image.open('C:\\Users\\itint2\\Desktop\\pso_logo.png')
background_image = ImageTk.PhotoImage(image)
resized_image = image.resize((200, 200))  # Adjust the size as needed
image_tk = ImageTk.PhotoImage(resized_image)

# Create a Label widget to display the background image
background_label = tk.Label(window, image=background_image)
background_label.place(x=0, y=-20, relwidth=1, relheight=1)

# Create a style for the button
style = ttk.Style()
style.theme_use("clam")

# Configure the style with desired properties
style.configure(
    "RoundedButton.TButton",
    # Black
    foreground="#000000",
    # Light Green
    background="#c7eaff",
    font=("Raleway", 15),
    bordercolor="#000000",
    lightcolor="#37fa64",
    darkcolor="#37fa64"
)


# Function to change the button background on mouse hover
def on_enter(event):
    style.map("RoundedButton.TButton", background=[("active", "#006400")], foreground=[("active", "white")])


# Function to change the button background on mouse leave with a slight delay
def on_leave(event):
    window.after(50, lambda: style.map("RoundedButton.TButton", background=[("active", "#006400")],
                                       foreground=[("active", "white")]))


window.title("Nozzles Sales Excel File Converter")
# Create the title label and center it horizontally
title_label = tk.Label(window, text="Nozzles Sales Excel File Converter", font=("Raleway", 32, "bold"), bg="#CCFFCC", fg="#000000")
title_label.pack(pady=20, anchor="w", padx=int(window.winfo_reqwidth() * 0.1), fill="x")

generated_label = tk.Label(window, text="> tables generated", font=("Raleway", 12, "bold"), bg="#FBEC5D", fg="#333333")
generated_label.pack_forget()


def perform_function():
    file_path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx;*.xls")])
    # Read the Excel file into a Pandas DataFrame
    data = pd.read_excel(file_path)

    data = data.dropna(how='all')
    data['Current Time'] = data['Current Time'].astype(str)
    data['Timestamp'] = pd.to_datetime(data['Date'].dt.strftime('%Y-%m-%d') + ' ' + data['Current Time'])
    data = data.drop(columns=['Date', 'Current Time'])
    data['key'] = data['Customer'].astype(str) + ' | ' + data['Nozzel'].astype(str) + ' | ' + data[
        'Dispenser ID'].astype(str)
    data = data.sort_values(by=['key', 'Timestamp'], ascending=[True, True])

    def weight_factor(Timestamp):
        hour = Timestamp.hour
        if 6 <= hour < 20:
            return 0.7
        else:
            return 0.3

    data['Filled'] = data['Values'].copy()

    for key in data['key'].unique():
        mask = (data['key'] == key)
        dispenser_data = data[mask]
        missing_mask = dispenser_data['Filled'].isnull() | (dispenser_data['Filled'] == 0)

        if missing_mask.any():
            for index, row in dispenser_data.iterrows():
                if missing_mask.loc[index]:
                    prev_rows = dispenser_data.loc[:index].loc[~missing_mask].tail(15)
                    next_rows = dispenser_data.loc[index:].loc[~missing_mask].head(15)

                    if not prev_rows.empty:
                        prev_row = prev_rows.iloc[-1]
                        prev_value = prev_row['Values']
                    else:
                        prev_value = np.nan

                    if not next_rows.empty:
                        next_row = next_rows.iloc[0]
                        next_value = next_row['Values']
                    else:
                        next_value = np.nan

                    if not pd.isnull(prev_value) and not pd.isnull(next_value):
                        time_diff = (next_row['Timestamp'] - prev_row['Timestamp']).total_seconds()
                        interp_value = prev_value + ((next_value - prev_value) / time_diff) * (
                            (row['Timestamp'] - prev_row['Timestamp']).total_seconds())

                        # Apply weight factor based on time
                        weight = weight_factor(row['Timestamp'])
                        sales_diff = (next_value - prev_value) * weight
                        interp_value = prev_value + sales_diff

                        # Ensure increasing trend
                        if interp_value >= next_value:
                            interp_value = next_value - 1e-6

                    elif not pd.isnull(prev_value):
                        # Backward fill
                        interp_value = prev_value - 0.5

                    elif not pd.isnull(next_value):
                        # Forward fill
                        interp_value = next_value - 0.5

                    data.at[index, 'Filled'] = interp_value

    mse_interpolation = mean_squared_error(data.loc[data['Values'] == 0, 'Values'],
                                           data.loc[data['Values'] == 0, 'Filled'])

    data["Unfilled"] = data["Values"]
    data["Values"] = data["Filled"]
    data.drop(["Filled"], axis="columns", inplace=True)

    data['Value Difference'] = data['Values'].diff()
    data.insert(0, 'ID', range(1, len(data) + 1))

    # REVEALING POSITIVE ANOMALIES

    benchmark = 500

    pos_anom_rows = data[
        (data['Value Difference'] > benchmark) & (data['Dispenser ID'] == data['Dispenser ID'].shift(1))].copy()

    # POSITIVE ANOMALIES

    pos_anom = data[
        (data['Value Difference'] > benchmark) & (data['Dispenser ID'] == data['Dispenser ID'].shift(1))].copy()

    # Iterate over each row in "pos_anom" and update the corresponding row in "data"
    for index, row in pos_anom.iterrows():
        time2 = pd.to_datetime(data.loc[data['ID'] == row['ID'], 'Timestamp'].values[0]).time()

        dummy_date1 = datetime(1, 1, 1)
        time2_datetime = datetime.combine(dummy_date1, time2)
        time2_minus_30mins = (time2_datetime - timedelta(minutes=30)).time()
        time2_plus_30mins = (time2_datetime + timedelta(minutes=30)).time()

        # Filter rows based on conditions, excluding the current row
        filtered_rows = data[(data['Value Difference'] > 0) & (data['Value Difference'] < benchmark) &
                             (data['Dispenser ID'] == row['Dispenser ID']) & (data.index != row.name)]

        filtered_rows2 = data[(data['Value Difference'] > 0) &
                              (data['Value Difference'] < benchmark) &
                              (data['Dispenser ID'] == row['Dispenser ID']) &
                              (data.index != row.name) &
                              ((pd.to_datetime(
                                  data.loc[data['ID'] == row['ID'], 'Timestamp'].values[
                                      0]).time()) > time2_minus_30mins) &
                              ((pd.to_datetime(
                                  data.loc[data['ID'] == row['ID'], 'Timestamp'].values[
                                      0]).time()) < time2_plus_30mins)]

        # Calculate the average of "Value Difference" for the filtered rows
        average_value_diff1 = filtered_rows['Value Difference'].mean()
        average_value_diff2 = filtered_rows2['Value Difference'].mean()

        weighted_average2 = average_value_diff1 * 0.2 + average_value_diff2 * 0.8

        row['Value Difference'] = weighted_average2

        ID_value = data.at[index, 'ID']

        matching_row2 = data[data['ID'] == ID_value]
        value_difference1 = matching_row2['Value Difference'].values[0]

        # Find the index of the row to replace
        index_to_replace = data[data['ID'] == ID_value].index[0]

        # Replace the row in the DataFrame
        data.loc[index_to_replace] = row

    # REVEALING NEGATIVE ANOMALIES

    target_ids = []
    value_diffs = []

    # Iterate over the rows in the dataframe
    for i in range(1, len(data)):
        if data.at[i, 'Values'] < data.at[i - 1, 'Values'] and data.at[i, 'Dispenser ID'] == data.at[
            i - 1, 'Dispenser ID']:
            target_ids.append(data.at[i, 'ID'])
            value_diffs.append(data.at[i, 'Value Difference'])

    # NEGATIVE ANOMALIES

    def calculate_average(ID_index):
        disp_id_value = data.loc[data['ID'] == ID_index, 'Dispenser ID'].values[0]

        # Find the indices of the five nearest non-zero, non-negative entries with the same nozzle value
        indices = []

        current_index = ID_index - 1

        time1 = pd.to_datetime(data.loc[data['ID'] == ID_index, 'Timestamp'].values[0]).time()

        dummy_date = datetime(1, 1, 1)

        time1_datetime = datetime.combine(dummy_date, time1)

        time1_minus_30mins = (time1_datetime - timedelta(minutes=30)).time()
        time1_plus_30mins = (time1_datetime + timedelta(minutes=30)).time()

        while len(indices) < 10 and current_index > 0:
            time_check1 = pd.to_datetime(data.loc[data['ID'] == current_index, 'Timestamp'].values[0]).time()
            if data.loc[data['ID'] == current_index, 'Value Difference'].values[0] > 0 and data.loc[
                data['ID'] == current_index, 'Dispenser ID'].values[
                0] == disp_id_value and time_check1 > time1_minus_30mins and time_check1 < time1_plus_30mins:
                indices.append(current_index)
            current_index -= 1

        current_index = ID_index + 1
        while len(indices) < 20 and current_index < len(data):
            time_check2 = pd.to_datetime(data.loc[data['ID'] == current_index, 'Timestamp'].values[0]).time()
            if data.loc[data['ID'] == current_index, 'Value Difference'].values[0] > 0 and data.loc[
                data['ID'] == current_index, 'Dispenser ID'].values[
                0] == disp_id_value and time_check2 > time1_minus_30mins and time_check2 < time1_plus_30mins:
                indices.append(current_index)
            current_index += 1

        # Calculate the average of the selected values

        # Select rows based on 'ID' column values in 'indices'
        selected_rows = data.loc[data['ID'].isin(indices)]

        # Extract "Value Difference" column entries as a list
        selected_values = selected_rows['Value Difference'].tolist()

        average = np.mean(selected_values)

        if average == 0:
            return

        # Filter the data frame based on the dispenser ID and excluding the specific ID
        same_disp_id_rows = data[(data['Dispenser ID'] == disp_id_value) & (data['ID'] != current_index) & (
                data['Value Difference'] > 0)]

        # Calculate the average of the "Value Difference" column
        average0 = same_disp_id_rows['Value Difference'].mean()

        weighted_average = average * 0.8 + average0 * 0.2

        return weighted_average

    filtered_rows = data[(data['Value Difference'] < 0) & (data['Values'] != 0) & (
            data['Dispenser ID'] == data['Dispenser ID'].shift(1))]

    # Update the 'Value Difference' column for filtered rows in data
    for index, row in filtered_rows.iterrows():
        ID_index = data.loc[index, 'ID']
        data.loc[data['ID'] == ID_index, 'Value Difference'] = calculate_average(data.loc[index, 'ID'])

    data.to_csv('output_data.csv', index=False)

    generated_label.pack(anchor="w", padx=20, pady=int(window.winfo_reqheight() * 0.1))
    # Hide the "Select File" button
    button.pack_forget()

    button1 = ttk.Button(window, text="Download tables", command=download_tables,
                         style="RoundedButton.TButton", width=20)
    button1.pack(padx=20, pady=(400, 20))  # Adjust the pady value as per your requirement

    # Place the "Tables Generated" label slightly above the "Download Tables" button
    button1.update()
    label_y = button1.winfo_y() - generated_label.winfo_height() - 10
    generated_label.place(relx=0.5, y=label_y, anchor="center")

    # Place the "Download Tables" button below the "Tables Generated" label
    button1.place(relx=0.5, y=label_y + generated_label.winfo_height() + 20, anchor="center")


def download_tables():
    # Ask the user to choose a directory to save the ZIP file
    selected_directory = filedialog.askdirectory()

    if not selected_directory:
        print("No directory selected. ZIP file not saved.")
        return

    zip_file_path = os.path.join(selected_directory, 'output_data.zip')

    # Create a ZIP file and add the CSV files to it
    with zipfile.ZipFile(zip_file_path, 'w') as zip_file:
        zip_file.write('output_data.csv')

    # Remove the temporary CSV files after they are added to the ZIP
    os.remove('output_data.csv')


button = ttk.Button(
    text="Select File",
    command=perform_function,  # No parentheses here
    style="RoundedButton.TButton",
    width=20,
)
button.pack(padx=20, pady=(505, 20))
# Adjust the pady value as needed

# Bind mouse events to change button background
button.bind("<Enter>", on_enter)
button.bind("<Leave>", on_leave)

# Run the Tkinter event loop
window.mainloop()
